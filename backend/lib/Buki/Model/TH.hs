module Buki.Model.TH where
-- ^ This module helps reducing boilerplate code when defining the
-- database entities. It is used by the @Buki.Model.Types.*@ modules
-- and the @Buki.Model.Tables@ module.
--
-- The general layout of a database entity is as follows:
--
-- * A data type named @Foo'@ with a type parameter for each record
--   field and a type constructor @Foo@.
-- * A data type named @Foo@ that corresponds to the Haskell representation
--   of the record.
-- * A data type named @FooField@ that corresponds to the database
--   representation of the record.
-- * A data type named @FooFieldW@ that corresponds to the database
--   representation of the record for the sake of writing operations. As
--   the database is able to generate UUIDs, we need to distinguish
--   between the two cases.
--
-- The @Foo@, @FooField@ and @FooFieldW@ types are generated by the
-- @makeDbAliases@ function from the @Foo'@ type and the list of types
-- of the record fields.
--
-- The database representation of a Haskell type is determined by the
-- @SqlType@ type family.
--
-- The table definition @userTable@ is generated by the @makeDbTable@
-- function, which takes the name of the table and the base enitity type,
-- e.g. @Foo'@.

import  Language.Haskell.TH

import Control.Lens

import Data.Char (toLower, isUpper)
import Data.Text (Text)
import Data.Time (LocalTime, UTCTime)
import Data.Time.Calendar (Day)
import Data.UUID (UUID)

import qualified Opaleye as O

import Buki.Model.Types.Id
import Buki.Model.Types.LoanState
import Buki.Model.Types.Permissions

import qualified Buki.Types as Ty

type family SqlType a

  -- Ids and related stuff:
type instance SqlType (Id a) = O.Field O.SqlUuid
type instance SqlType (Maybe (Id a)) = O.FieldNullable O.SqlUuid
type instance SqlType UUID = O.Field O.SqlUuid
type instance SqlType (Maybe UUID) = O.FieldNullable O.SqlUuid

-- Text:
type instance SqlType Text = O.Field O.SqlText
type instance SqlType (Maybe Text) = O.FieldNullable O.SqlText

-- Date and time:
type instance SqlType Day = O.Field O.SqlDate
type instance SqlType (Maybe Day) = O.Field O.SqlDate
type instance SqlType LocalTime = O.Field O.SqlTimestamp
type instance SqlType (Maybe LocalTime) = O.FieldNullable O.SqlTimestamp
type instance SqlType UTCTime = O.Field O.SqlTimestamptz
type instance SqlType (Maybe UTCTime) = O.FieldNullable O.SqlTimestamptz

-- Primitive types:
type instance SqlType Int = O.Field O.SqlInt4
type instance SqlType Bool = O.Field O.SqlBool

-- Custom enums:
type instance SqlType LoanState = O.Field SqlLoanState
type instance SqlType Permissions = O.Field SqlPermissions

-- Strong types:
type instance SqlType Ty.Name = O.Field O.SqlText
type instance SqlType Ty.EmailAddress = O.Field O.SqlText
type instance SqlType Ty.Password = O.Field O.SqlText

makeDbAliases :: Name -> [Q Type] -> Q [Dec]
makeDbAliases recordName types = do
  let baseName = init $ nameBase recordName

  expandedTypes <- sequenceA types

  let haskellRecordType = foldl AppT (ConT recordName) expandedTypes
  let haskellRecordTypeName = mkName baseName
  let haskellRecordTypeAlias = TySynD haskellRecordTypeName [] haskellRecordType

  fieldTypes <- mapM promoteToFieldType expandedTypes
  let sqlReadRecordType = foldl AppT (ConT recordName) fieldTypes
  let sqlReadRecordTypeName = mkName $ baseName ++ "Field"
  let sqlReadRecordTypeAlias = TySynD sqlReadRecordTypeName [] sqlReadRecordType

  return [haskellRecordTypeAlias, sqlReadRecordTypeAlias]

  where promoteToFieldType :: Type -> Q Type
        promoteToFieldType ty = do
          let name = "SqlType"
          promoted <- lookupTypeName name
          case promoted of
            Nothing -> fail $ "Could not find type " ++ name
            Just promotedName -> return $ AppT (ConT promotedName) ty

makeDbTable :: String -> Name -> Q [Dec]
makeDbTable tableName baseName = do
  let lowerHead = over _head toLower
  let baseNameStr = nameBase baseName
  let baseValueNameStr = lowerHead baseNameStr
  let fieldPrefix = baseValueNameStr ++ "'"
  let functionName = mkName $ baseValueNameStr ++ "Table"
  let sqlType = mkName $ baseNameStr ++ "Field"
  let sqlTableType = ConT ''O.Table `AppT` ConT sqlType `AppT` ConT sqlType

  recordInfo <- reify (mkName $ baseNameStr ++ "'")
  case recordInfo of
    TyConI (DataD _ _ _ _ [RecC _ fields] _) ->
      let
        stripPrefix :: String -> String -> String
        stripPrefix (p:ps) (s:ss)
          | p == s = stripPrefix ps ss
          | otherwise = fail "Unexpected field name!"
        stripPrefix [] ss = ss
        stripPrefix _ _ = fail "Unexpected field name!"
        makeTableField :: (Name, Bang, Type) -> Q FieldExp
        makeTableField (name, _, _) = do
          expr <- varE 'O.tableField `appE`
                    stringE (toUnderscores $ lowerHead $ stripPrefix fieldPrefix $ nameBase name)
          pure (name, expr)
        makeTable :: [(Name, Bang, Type)] -> Q Exp
        makeTable fs = do
          varE 'O.table
            `appE` stringE tableName
            `appE` (varE (mkName $ "p" ++ baseNameStr)
                    `appE` recConE (mkName baseNameStr) (map makeTableField fs))
       in do
         table <- makeTable fields
         pure [ SigD functionName sqlTableType
              , FunD functionName [Clause [] (NormalB table) []]
              ]
    _ -> fail "Could not find record type!"

toUnderscores :: String -> String
toUnderscores (x:xs)
  | isUpper x = '_' : toLower x : toUnderscores xs
  | otherwise = x : toUnderscores xs
toUnderscores [] = []
