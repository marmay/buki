module Buki.Model.TH where
-- ^ This module helps reducing boilerplate code when defining the
-- database entities. It is used by the @Buki.Model.Types.*@ modules
-- and the @Buki.Model.Tables@ module.
--
-- The general layout of a database entity is as follows:
--
-- * A data type named @Foo'@ with a type parameter for each record
--   field and a type constructor @Foo@.
-- * A data type named @Foo@ that corresponds to the Haskell representation
--   of the record.
-- * A data type named @FooField@ that corresponds to the database
--   representation of the record.
-- * A data type named @FooFieldW@ that corresponds to the database
--   representation of the record for the sake of writing operations. As
--   the database is able to generate UUIDs, we need to distinguish
--   between the two cases.
--
-- The @Foo@, @FooField@ and @FooFieldW@ types are generated by the
-- @makeDbAliases@ function from the @Foo'@ type and the list of types
-- of the record fields.
--
-- The database representation of a Haskell type is determined by the
-- @SqlType@ type family.
--
-- The table definition @userTable@ is generated by the @makeDbTable@
-- function, which takes the name of the table and the base enitity type,
-- e.g. @Foo'@.

import  Language.Haskell.TH

import Control.Lens

import Data.Char (toLower, isUpper)

import qualified Opaleye as O


requiredTableMaybeField ::
  String ->
  O.TableFields (O.MaybeFields (O.Field a)) (O.MaybeFields (O.Field a))
requiredTableMaybeField name =
  dimap (\mf -> O.matchMaybe mf $ \case
            Nothing -> O.null
            Just x -> O.toNullable x)
        O.nullableToMaybeFields
        (O.requiredTableField name)

makeDbAliases :: Name -> [Q Type] -> Q [Dec]
makeDbAliases recordName types = do
  let baseName = init $ nameBase recordName

  expandedTypes <- sequenceA types

  let haskellRecordType = foldl AppT (ConT recordName) expandedTypes
  let haskellRecordTypeName = mkName baseName
  let haskellRecordTypeAlias = TySynD haskellRecordTypeName [] haskellRecordType

  fieldTypes <- mapM promoteToFieldType expandedTypes
  let sqlReadRecordType = foldl AppT (ConT recordName) fieldTypes
  let sqlReadRecordTypeName = mkName $ baseName ++ "Field"
  let sqlReadRecordTypeAlias = TySynD sqlReadRecordTypeName [] sqlReadRecordType

  return [haskellRecordTypeAlias, sqlReadRecordTypeAlias]

  where promoteToFieldType :: Type -> Q Type
        promoteToFieldType ty = do
          let name = "SqlType"
          promoted <- lookupTypeName name
          case promoted of
            Nothing -> fail $ "Could not find type " ++ name
            Just promotedName -> return $ AppT (ConT promotedName) ty

makeDbTable :: String -> Name -> Q [Dec]
makeDbTable tableName baseName = do
  let baseNameStr = nameBase baseName
  let baseValueNameStr = lowerHead baseNameStr
  let fieldPrefix = baseValueNameStr ++ "'"
  let functionName = mkName $ baseValueNameStr ++ "Table"
  let haskellType = mkName baseNameStr
  let sqlType = mkName $ baseNameStr ++ "Field"
  let sqlTableType = ConT ''O.Table `AppT` ConT sqlType `AppT` ConT sqlType

  fieldNames <- getFieldNames (mkName $ baseNameStr <> "'")
  fieldTypes <- getTySynTypes haskellType
  -- _ <- error $ "makeTable" <> show (fieldNames `zip` fieldTypes)
  table <- makeTable baseNameStr fieldPrefix $ fieldNames `zip` fieldTypes
  pure [ SigD functionName sqlTableType
       , FunD functionName [Clause [] (NormalB table) []]
       ]
  where
    getFieldNames :: Name -> Q [Name]
    getFieldNames name = do
      info <- reify name
      case info of
        TyConI (DataD _ _ _ _ [RecC _ fields] _) -> pure $ map (\(n, _, _) -> n) fields
        _ -> fail "Could not find record type!"

    getTySynTypes :: Name -> Q [Type]
    getTySynTypes name = do
      info <- reify name
      case info of
        TyConI (TySynD _ _ ty) -> getAppliedTypes ty []
        _ -> fail "Could not find type synonym!"

    getAppliedTypes :: Type -> [Type] -> Q [Type]
    getAppliedTypes (AppT t1 t2) acc = getAppliedTypes t1 (t2 : acc)
    getAppliedTypes _ acc = pure acc

    stripPrefix :: String -> String -> String
    stripPrefix (p:ps) (s:ss)
      | p == s = stripPrefix ps ss
      | otherwise = fail "Unexpected field name!"
    stripPrefix [] ss = ss
    stripPrefix _ _ = fail "Unexpected field name!"

    isMaybe :: Type -> Bool
    isMaybe (AppT (ConT maybeCon) _) = maybeCon == ''Maybe
    isMaybe _ = False

    tableFieldGen :: Type -> Name
    tableFieldGen ty
      | isMaybe ty = 'requiredTableMaybeField
      | otherwise  = 'O.requiredTableField

    makeTableField :: String -> (Name, Type) -> Q FieldExp
    makeTableField fieldPrefix (name, ty) = do
      expr <- varE (tableFieldGen ty) `appE`
                stringE (toUnderscores $ lowerHead $ stripPrefix fieldPrefix $ nameBase name)
      pure (name, expr)

    makeTable :: String -> String -> [(Name, Type)] -> Q Exp
    makeTable baseNameStr fieldPrefix fs = do
      varE 'O.table
        `appE` stringE tableName
        `appE` (varE (mkName $ "p" ++ baseNameStr)
                `appE` recConE (mkName baseNameStr) (map (makeTableField fieldPrefix) fs))

    lowerHead = over _head toLower

toUnderscores :: String -> String
toUnderscores (x:xs)
  | isUpper x = '_' : toLower x : toUnderscores xs
  | otherwise = x : toUnderscores xs
toUnderscores [] = []
